\documentclass[letterpaper,11pt]{article}
\usepackage{amsmath}
\usepackage{moreverb}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{float}
\usetikzlibrary{arrows,shapes, positioning}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\let\biconditional\leftrightarrow
\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}
\newenvironment{customlegend}[1][]{%
    \begingroup
    % inits/clears the lists (which might be populated from previous
    % axes):
    \csname pgfplots@init@cleared@structures\endcsname
    \pgfplotsset{#1}%
}{%
    % draws the legend:
    \csname pgfplots@createlegend\endcsname
    \endgroup
}%

% makes \addlegendimage available (typically only available within an
% axis environment):
\def\addlegendimage{\csname pgfplots@addlegendimage\endcsname}

\pgfkeys{/pgfplots/number in legend/.style={%
        /pgfplots/legend image code/.code={%
            \node at (0.295,-0.0225){#1};
        },%
    },
}

\title{Distributed Systems -- Deliverable 2}
\author{Jacob Errington (260636023) \\ Alexandre Laporte (260635979)}
\date{6 October 2015}

\begin{document}

\maketitle

For this deliverable, we choose to extend the TCP sockets implementation from
the first deliverable. In order to distribute this application we created
the \texttt{MiddlewareResourceManager} class implementing the same interface as
the backend servers. Hence, from a client's perspective, it is
indistinguishable from a backend server.

In simple cases, the middleware dispatches incoming requests to a backend
server according to the type of request. Once the backend server's reply is
received, it is transmitted back to the client.

More complex requests such as reservations require additional work from the
middleware server. For example, in order to reserve a flight, the middleware
must first ensure that the customer exists by querying the customer server,
and then reserves the flight by sending a request to the flight server. The
case of printing a bill is even more complicated as it requires querying every
backend server once.

\begin{figure}[H]
    \centering

    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,semithick]
        \node[draw] (rect) (client)                             {Client};
        \node[draw] (rect) (middleware) [right of=client,xshift=2cm] {Middleware Layer};

        \node[draw] (rect) (flight) [right of=middleware,xshift=3.75cm] {Flight Server};
        \node[draw] (rect) (car) [above of=flight]                  {Car Server};
        \node[draw] (rect) (room) [below of=flight]                 {Room Server};
        \node[draw] (rect) (customer) [below of=room] 	           {Customer Server};

        \node[draw] (rect) (flightDB) [right of=flight, xshift=3cm]   {Flight Datastore};
        \node[draw] (rect) (carDB) [right of=car, xshift=3cm]      {Car Datastore};
        \node[draw] (rect) (roomDB) [right of=room, xshift=3cm]     {Room Datastore};
        \node[draw] (rect) (customerDB) [right of=customer, xshift=3cm] {Customer Datastore};

        \path
        (client)     edge                node {} (middleware)
        (middleware) edge                node {} (flight)
                     edge                node {} (car)
                     edge                node {} (room)
                     edge		        node {}  (customer)
        (flight)     edge                node {} (flightDB)
        (car)        edge                node {} (carDB)
        (room)       edge                node {} (roomDB)
        (customer)   edge 		        node {}  (customerDB);
    \end{tikzpicture}

    \caption{
        The architecture of our system uses a middleware server to contact
        independent backend servers to perform tasks related to different types
        of reservable items. Each backend server uses in-memory synchronized
        hashtables to store their respective data. Furthermore, each backend
        server is equipped with a lock manager enabling it to perform strict
        two-phase locking. Since each backend server has its own datastore,
        data consistency across backend servers is maintained by the
        middleware. The middleware is equipped with a transaction manager to
        guarantee consistently incrementing identifiers for transactions as
        they are requested by the clients. Also, the middleware manages
        timeouts for transactions as a way of resolving deadlocks.
    }
\end{figure}

At the core of both the middleware and backend servers, there is a tight loop
that accepts incoming connections. Upon each new connection being established,
a handler is created for that connection and is run in a different thread. We
use a pool with a fixed number of threads based on the number of logical
processors on the machine. Consequently, new connections may be accepted while
requests are being handled in these worker threads, and many requests may be
processed concurrently.

Objects are sent over the network using Java's built-in serialization
capabilities. However, we pass only two types of objects over the network.

\begin{description}
    \item[Request.] A request object represents a remote method invocation on
        the recipient server's ResourceManager. As such, it simply contains the
        name of the method to invoke, an array of objects to use as parameters,
        and some metadata on the parameters. The request object implements a
        method using reflection to invoke the method on a provided object
        implementing the resource manager interface. This allows us to remain
        agnostic about the precise implementation of this interface, and
        consequently, we can use identical request objects for both
        client-middleware and middleware-backend communications.

    \item[Response.] A response object represents the return value of the
        remote method invocation. Since remote method invocations may abruptly
        fail, we bracket the method calls with exception handlers that
        package the exception into the response object and return it to the
        client, where it is thrown again. This allows exceptions to
        transparently be thrown across the network, and prevents exceptions
        raised by event handler code from crashing the socket accept loop.
        However, clients and the middleware must take care to check for these
        exceptions as they are unchecked.
\end{description}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,semithick]
        \node[draw] (rect) (B) [xshift=4cm] {ResourceManager};
        \node[draw] (rect) (A) [right of=B, xshift=2.5cm]                {SocketResourceManager};
        \node[draw] (rect) (E) [below of=A]      {MiddlewareResourceManager};
        \node[draw] (rect) (C) [below of=E]      {CustomerResourceManager};
        \node[draw] (rect) (D) [below of=C]      {ItemResourceManager};
        \path
        (A) edge node {} (B)
        (C) edge[bend left=20] node {} (B)
        (D) edge[bend left=30] node {} (B)
        (E) edge node {} (B)
        (E) edge[dashed]       node {} (A)
        ;

        \begin{customlegend}[
            legend entries={ % <= in the following there are the entries
                implements,
                aggregates
            }
        ] % <= to define position and font legend
          % the following are the "images" and numbers in the legend
            \addlegendimage{-stealth,black,opacity=1}
            \addlegendimage{black,dashed,opacity=0.5}
        \end{customlegend}
    \end{tikzpicture}

    \caption{
        Each component of the system is represented by a class implementing the
        \texttt{ResourceManager} interface, which defines the basic set of
        capabilities that can be performed on reservable items.
        Backend servers use a \texttt{CustomerResourceManager} or a
        \texttt{ItemResourceManager} to perform actions on their respective
        backing store,  according to the type of data that they manage.
        Clients use a \texttt{SocketResourceManager} to send \texttt{Request}
        objects representing the remote methods to call.
        The middleware server's \texttt{MiddlewareResourceManager} aggregates a
        number of \texttt{SocketResourceManager}s, one for each connected
        backend server. Many requests received by the middleware simply need
        to be forwarded to the appropriate backend server, but some requests
        require aggregating data across all nodes in order to present summary
        information to the client.
    }
\end{figure}

\section*{Performance}

Below we show the performance of distributed transactions in the system.
Figure \ref{fig:performance-vs-tps} shows the performance of the system under
concurrent loads, whereas figure \ref{fig:throughput} presents an evaluation of
the throughput of the system.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figure.pdf}
    \caption{
        Requests are submitted by ten clients concurrently at an
        increasing rate. The performance of the system as the rate of
        transactions being submitted increases degrades as expected in a
        slightly sublinear fashion.
    }
    \label{fig:performance-vs-tps}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{bars.pdf}
    \caption{
        A single client bombards the system with requests in order to evaluate
        the overall throughput of the system according to the complexity of the
        submitted requests. Requests involving one, two, and three independent
        backend servers are submitted. Despite the varying complexity of these
        requests, the difference in average response times are not significant.
    }
    \label{fig:throughput}
\end{figure}

\end{document}
