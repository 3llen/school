\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{tikz}
\usepackage[margin=2.0cm]{geometry}

\author{Jacob Thomas Errington (260636023)}
\title{Assignment \#1\\Distributed Systems -- COMP 512}
\date{20 October 2015}

\newcommand{\ms}{\text{ ms}}

\begin{document}

\maketitle

\section{Minis}

\begin{enumerate}
    \item
        In an asynchronous system, a process $p$ requests the time from a time
        server $S$, with a measured round-trip time of $24\ms$, and $p$
        receives $t = 10:54:23:674$ from $S$.

        \begin{enumerate}
            \item
                $p$ would set it's local clock to the received time, plus half
                the round-trip time, i.e.
                $$
                ps
                = t + \frac{T_\text{round}}{2}
                = 10 : 54 : 23 : 674 + 0 : 0 : 0 : 12
                = 10 : 54 : 23 : 698
                $$

            \item
                If $p$'s local time upon receipt of the response from $S$ is
                $ps = 10 : 54 : 24 : 005$, then setting its time to the value
                calculated above would result in a ``jump back in time''. This
                violates the expected monotonicity of the system clock. To
                remedy this, the system can run it's local clock more slowly
                for some time, to have it eventually become synchronized with
                the received time.
        \end{enumerate}

    \item
        There are many ways to marshal program data into a form suitable
        for transmission: XML (similarly JSON), Java's serialization, and
        Google Protocol Buffer, as well as others. For each of these three
        methods, here is an advantage it has over the other two.

        \begin{enumerate}
            \item
                XML and JSON have the advantage of being human-readable,
                text formats; if data is inspected while in transit, it can
                be understood without any additional tooling by a
                developer.

            \item
                Java's built-in serialization has the advantage of being
                extremely easy to use, from a developer's point of view.
                No additional libraries are required, since the
                functionality is built directly into the base Java Runtime
                Environment.

            \item
                Google Protocol Buffer is a binary format, like Java's
                built-in serialization, but is not tied to Java, so it can
                be used to interact with non-Java environments. It is also
                much faster than XML.
        \end{enumerate}

    \item
        Below are timestamped diagrams of the communications between three
        processes. The first diagram uses a Lamport clock, whereas the
        second diagram uses a vector clock.

        \begin{figure}
            \centering

            \label{fig:lamport-timestamp}

            \begin{tikzpicture}
                [
                    ->,
                    shorten >=1pt,
                    auto,
                    node distance=3.0cm,
                    semithick,
                    event/.style={shape=circle, fill=gray},
                    event delayed/.style={event, node distance=3.5cm},
                    timeline/.style={color=blue!70, very thin, -},
                    time endpoint/.style={node distance=16cm},
                    msg send/.style={node distance=2.0cm},
                    msg recv/.style={node distance=2.0cm},
                    msg send slow/.style={node distance=4.0cm},
                    msg recv slow/.style={node distance=4.0cm},
                    msg send very slow/.style={node distance=6.0cm},
                    msg recv very slow/.style={node distance=6.0cm}
                ]
                \node (p1)                                    {$p_1$};
                \node (p2) [below of=p1, node distance=2.5cm] {$p_2$};
                \node (p3) [below of=p2, node distance=2.5cm] {$p_3$};

                \node (end p1)
                      [right of=p1, time endpoint]
                      {};
                \node (end p2)
                      [right of=p2, time endpoint]
                      {};
                \node (end p3)
                      [right of=p3, time endpoint]
                      {};


                \path
                (p1) edge [timeline] node {} (end p1)
                (p2) edge [timeline] node {} (end p2)
                (p3) edge [timeline] node {} (end p3)
                ;

                \node (event p1 1)
                      [event, right of=p1, label=90:$1$]
                      {};

                \node (event p2 1)
                      [event, right of=p2, event delayed, label=90:$1$]
                      {};

                \node (event p1 2)
                      [event, right of=event p1 1, label=90:$3$]
                      {};

                \node (m1 send)
                      [msg send, right of=event p1 1, label=90:$2$]
                      {};

                \node (m1 recv)
                      [msg recv, right of=event p2 1, label=270:$3$]
                      {};

                \node (m2 send)
                      [msg send, right of=m1 recv, label=90:$4$]
                      {};

                \node (m2 recv)
                      [msg recv, right of=p3, node distance=8cm, label=270:$5$]
                      {};

                \node (m3 send)
                      [msg send, right of=m2 send, label=90:$5$]
                      {};

                \node (m5 send)
                      [msg send, right of=event p1 2, label=90:$4$]
                      {};

                \node (m4 send)
                      [msg send, right of=m2 recv, label=270:$6$]
                      {};

                \node (m5 recv)
                      [msg recv slow, right of=m3 send, label=90:$6$]
                      {};

                \node (m4 recv)
                      [msg recv slow, right of=m5 send, label=90:$7$]
                      {};

                \node (m3 recv)
                      [msg recv, right of=m4 recv, label=90:$8$]
                      {};

                \node (event p3 1)
                      [event, right of=m4 send, label=90:$7$]
                      {};

                \path
                (m1 send) edge node {$m_1$} (m1 recv)
                (m2 send) edge node {$m_2$} (m2 recv)
                (m3 send) edge [pos=0.2] node {$m_3$} (m3 recv)
                (m4 send) edge [pos=0.25] node {$m_4$} (m4 recv)
                (m5 send) edge [pos=0.2] node {$m_5$} (m5 recv)
                ;

            \end{tikzpicture}

            \caption{
                A time series diagram of three intercommunicating processes
                with events annotated with their Lamport timestamps.
            }
        \end{figure}
\end{enumerate}

\end{document}
