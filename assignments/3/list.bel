LF nat:type =
| z : nat
| s : nat -> nat ;

LF leq: nat -> nat -> type =
| le_z: leq z N
| le_s: leq N M -> leq (s N) (s M);

rec ref: {N: [|-nat]} [|- leq N N] =
/ total n (ref n) /
mlam N => case [|- N] of
| [|- z] => [|- le_z]
| [|- s M] => let [|- P] = ref [|- M] in [|- le_s P];

% now lists

LF list : type =
| nil : list
| cons : nat -> list -> list
;

LF sorted : list -> type =
| sort_nil : sorted nil % empty lists are sorted
| sort_singleton : {N : nat} sorted nil -> sorted (cons N nil)
| sort_cons
    : sorted (cons M R)
    -> leq N M
    -> sorted (cons N (cons M R))
;

%query 1 1 P : sorted (cons (s (s z)) (cons (s (s (s (s z)))) (cons (s (s (s (s (s (s (s (s z)))))))) nil))).

%query 1 1 P : sorted (cons z (cons (s z) (cons (s (s z)) nil))).

%query 1 1 P : sorted (cons (s z) (cons (s (s (s z))) (cons (s (s (s (s (s z))))) nil))).

LF member : nat -> list -> type =
| here : member N (cons N R)
| there : member N R -> member N (cons M R)
;

%query 1 1 P : member (s z) (cons z (cons z (cons z (cons (s z) nil)))).

%query 1 1 P : member z (cons (s z) (cons (s z) (cons (s z) (cons z nil)))).

%query 1 1 P : member (s (s (s z))) (cons z (cons (s z) (cons (s (s z)) (cons (s (s (s z))) (cons (s (s (s (s z)))) nil))))).

LF insert : nat -> list -> list -> type =
| ins_nil : insert N nil (cons N nil)
| ins_here : leq N M -> insert N (cons M R) (cons N (cons M R))
| ins_there
    : leq M N
    -> insert N L L'
    -> insert N (cons M L) (cons M L')
;

%query 1 1 P : insert z nil (cons z nil).

%query 1 1 P : insert (s z) (cons z (cons (s (s z)) nil)) (cons z (cons (s z) (cons (s (s z)) nil))).

%query 1 1 P : insert (s (s z)) (cons z (cons z (cons z nil))) (cons z (cons z (cons z (cons (s (s z)) nil)))).
